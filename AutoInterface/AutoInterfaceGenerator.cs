using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace AutoInterface;

[Generator(LanguageNames.CSharp)]
public sealed class AutoInterfaceGenerator : IIncrementalGenerator {
    /// <summary>
    /// Container for 2 Nodes: The attribute AutoInterfaceAttribute together with the corresponding class/struct.
    /// </summary>
    /// <param name="Attribute"></param>
    /// <param name="Type"></param>
    private readonly record struct AttributeWithClass(AttributeSyntax Attribute, TypeDeclarationSyntax Type) : IEquatable<AttributeWithClass>;


    public void Initialize(IncrementalGeneratorInitializationContext context) {
        // register attribute marker
        context.RegisterPostInitializationOutput(static (IncrementalGeneratorPostInitializationContext context) => {
            context.AddSource("AutoInterfaceAttribute.g.cs", Attributes.AutoInterfaceAttribute);
            context.AddSource("IgnoreAutoInterfaceAttribute.g.cs", Attributes.IgnoreAutoInterfaceAttribute);
        });

        // all classes/structs with AutoInterfaceAttribute
        IncrementalValuesProvider<AttributeWithClass> interfaceTypeProvider = context.SyntaxProvider.CreateSyntaxProvider(Predicate, Transform);

        context.RegisterSourceOutput(interfaceTypeProvider, Execute);
    }


    private static bool Predicate(SyntaxNode syntaxNode, CancellationToken _) {
        if (syntaxNode is not AttributeSyntax attributeSyntax)
            return false;

        if (attributeSyntax.Parent?.Parent is not (ClassDeclarationSyntax or StructDeclarationSyntax))
            return false;


        string identifier = attributeSyntax.Name switch {
            SimpleNameSyntax simpleName => simpleName.Identifier.ValueText,
            QualifiedNameSyntax qualifiedName => qualifiedName.Right.Identifier.ValueText,
            _ => string.Empty
        };

        if (identifier != "AutoInterface" && identifier != "AutoInterfaceAttribute")
            return false;


        return true;
    }

    private static AttributeWithClass Transform(GeneratorSyntaxContext syntaxContext, CancellationToken _) {
        AttributeSyntax attribute = (AttributeSyntax)syntaxContext.Node;
        TypeDeclarationSyntax type = (TypeDeclarationSyntax)attribute.Parent!.Parent!;
        return new AttributeWithClass(attribute, type);
    }


    private static void Execute(SourceProductionContext context, AttributeWithClass provider) {
        (string name, string modifier, string namspace, string[] inheritance, bool staticMembers) attribute;
        if (provider.Attribute.ArgumentList != null) {
            attribute.name = provider.Attribute.ArgumentList.GetLiteral("Name")?.Token.ValueText ?? $"I{provider.Type.Identifier.ValueText}";
            attribute.modifier = provider.Attribute.ArgumentList.GetLiteral("Modifier")?.Token.ValueText ?? "public";
            attribute.namspace = provider.Attribute.ArgumentList.GetLiteral("Namespace")?.Token.ValueText ?? provider.Type.GetParent<BaseNamespaceDeclarationSyntax>()?.Name.ToString() ?? string.Empty;
            
            {
                attribute.inheritance = provider.Attribute.ArgumentList.GetExpression("Inheritance") switch {
                    ImplicitArrayCreationExpressionSyntax arrayExpression => ExpressionsToStringArray(arrayExpression.Initializer),
                    ArrayCreationExpressionSyntax arrayExpression => arrayExpression.Initializer switch {
                        InitializerExpressionSyntax initializerExpression => ExpressionsToStringArray(initializerExpression),
                        _ => Array.Empty<string>()
                    },
                    _ => Array.Empty<string>()
                };

                static string[] ExpressionsToStringArray(InitializerExpressionSyntax initializerExpression) {
                    string[] result = new string[initializerExpression.Expressions.Count];

                    for (int i = 0; i < initializerExpression.Expressions.Count; i++)
                        if (initializerExpression.Expressions[i] is TypeOfExpressionSyntax typeOfExpression)
                            result[i] = typeOfExpression.Type.ToString();
                    
                    return result;
                }
            }
            
            attribute.staticMembers = provider.Attribute.ArgumentList.GetLiteral("StaticMembers")?.Token.Value as bool? ?? false;
        }
        else {
            attribute.name = $"I{provider.Type.Identifier.ValueText}";
            attribute.modifier = "public";
            attribute.namspace = provider.Type.GetParent<BaseNamespaceDeclarationSyntax>()?.Name.ToString() ?? string.Empty;
            attribute.inheritance = Array.Empty<string>();
            attribute.staticMembers = false;
        }


        StringBuilder builder = new(65536);
        builder.Append("""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations



            """);

        // usingStatements
        CompilationUnitSyntax? compilationUnit = provider.Type.GetParent<CompilationUnitSyntax>();
        string usingStatements = compilationUnit?.Usings.ToString() ?? string.Empty;
        if (usingStatements != string.Empty) {
            builder.Append(usingStatements);
            builder.Append('\n');
            builder.Append('\n');
        }

        // namespace
        if (attribute.namspace != string.Empty) {
            builder.Append("namespace ");
            builder.Append(attribute.namspace);
            builder.Append(';');
            builder.Append('\n');
            builder.Append('\n');
        }

        // summary
        {
            SyntaxTriviaList triviaList = provider.Type.AttributeLists[0].GetLeadingTrivia();
            foreach (SyntaxTrivia trivia in triviaList)
                if (trivia.GetStructure() is DocumentationCommentTriviaSyntax documentationCommentTrivia) {
                    builder.Append("///");
                    builder.Append(documentationCommentTrivia.ToString());
                    break;
                }
        }
        // class/struct declaration
        builder.Append(attribute.modifier);
        builder.Append(" interface ");
        builder.Append(attribute.name);
        if (provider.Type.TypeParameterList?.Parameters.Count > 0) {
            builder.Append('<');

            foreach (TypeParameterSyntax parameter in provider.Type.TypeParameterList.Parameters) {
                builder.Append(parameter.Identifier.ValueText);
                builder.Append(',');
                builder.Append(' ');
            }

            builder.Length -= 2;
            builder.Append('>');
        }
        if (attribute.inheritance.Length > 0) {
            builder.Append(' ');
            builder.Append(':');
            builder.Append(' ');
            builder.Append(attribute.inheritance[0]);
            for (int i = 1; i < attribute.inheritance.Length; i++) {
                builder.Append(',');
                builder.Append(' ');
                builder.Append(attribute.inheritance[i]);
            }
        }
        builder.Append(' ');
        builder.Append('{');
        builder.Append('\n');

        foreach (MemberDeclarationSyntax member in provider.Type.Members) {
            switch (member) {
                case MethodDeclarationSyntax methodDeclarationSyntax: {
                    if (methodDeclarationSyntax.GetAttribute("IgnoreAutoInterface") != null)
                        break;

                    // public or explicit interface specifier
                    if (!methodDeclarationSyntax.Modifiers.Contains("public"))
                        if (!(methodDeclarationSyntax.ExplicitInterfaceSpecifier?.Name is IdentifierNameSyntax identifierSyntax && identifierSyntax.Identifier.ValueText == attribute.name))
                            break;

                    string? modifiers;
                    if (!methodDeclarationSyntax.Modifiers.Contains("static"))
                        modifiers = string.Empty; // object-method (non static)
                    else if (attribute.staticMembers)
                        modifiers = "static abstract "; // static-method and static is enabled
                    else
                        break;  // ignore static member


                    // summary
                    {
                        SyntaxTriviaList triviaList = methodDeclarationSyntax.AttributeLists.Count switch {
                            > 0 => methodDeclarationSyntax.AttributeLists[0].GetLeadingTrivia(),
                            _ => methodDeclarationSyntax.Modifiers.Count switch {
                                > 0 => methodDeclarationSyntax.Modifiers[0].LeadingTrivia,
                                _ => methodDeclarationSyntax.ReturnType.GetLeadingTrivia()
                            }
                        };
                        foreach (SyntaxTrivia trivia in triviaList)
                            if (trivia.GetStructure() is DocumentationCommentTriviaSyntax documentationCommentTrivia) {
                                builder.Append("    ///");
                                builder.Append(documentationCommentTrivia.ToString());
                                break;
                            }
                    }

                    builder.Append("    ");
                    builder.Append(modifiers);
                    builder.Append(methodDeclarationSyntax.ReturnType.ToString());
                    builder.Append(' ');
                    builder.Append(methodDeclarationSyntax.Identifier.ValueText);

                    builder.Append(methodDeclarationSyntax.ParameterList.ToString());
                    builder.Append(';');

                    builder.Append('\n');
                    builder.Append('\n');

                    break;
                }

                case PropertyDeclarationSyntax propertyDeclarationSyntax: {
                    if (propertyDeclarationSyntax.GetAttribute("IgnoreAutoInterface") != null)
                        break;

                    // public or explicit interface specifier
                    if (!propertyDeclarationSyntax.Modifiers.Contains("public"))
                        if (!(propertyDeclarationSyntax.ExplicitInterfaceSpecifier?.Name is IdentifierNameSyntax identifierSyntax && identifierSyntax.Identifier.ValueText == attribute.name))
                            break;

                    string? modifiers;
                    if (!propertyDeclarationSyntax.Modifiers.Contains("static"))
                        modifiers = string.Empty; // object-method (non static)
                    else if (attribute.staticMembers)
                        modifiers = "static abstract "; // static-method and static is enabled
                    else
                        break;  // ignore static member


                    // summary
                    {
                        SyntaxTriviaList triviaList = propertyDeclarationSyntax.AttributeLists.Count switch {
                            > 0 => propertyDeclarationSyntax.AttributeLists[0].GetLeadingTrivia(),
                            _ => propertyDeclarationSyntax.Modifiers.Count switch {
                                > 0 => propertyDeclarationSyntax.Modifiers[0].LeadingTrivia,
                                _ => propertyDeclarationSyntax.Type.GetLeadingTrivia()
                            }
                        };
                        foreach (SyntaxTrivia trivia in triviaList)
                            if (trivia.GetStructure() is DocumentationCommentTriviaSyntax documentationCommentTrivia) {
                                builder.Append("    ///");
                                builder.Append(documentationCommentTrivia.ToString());
                                break;
                            }
                    }

                    builder.Append("    ");
                    builder.Append(modifiers);
                    builder.Append(propertyDeclarationSyntax.Type.ToString());
                    builder.Append(' ');
                    builder.Append(propertyDeclarationSyntax.Identifier.ValueText);
                    builder.Append(' ');
                    
                    builder.Append('{');
                    builder.Append(' ');
                    if (propertyDeclarationSyntax.AccessorList != null)
                        foreach (AccessorDeclarationSyntax accessor in propertyDeclarationSyntax.AccessorList.Accessors) {
                            if (accessor.Modifiers.Count > 0) // non public
                                continue;

                            builder.Append(accessor.Keyword.ValueText);
                            builder.Append(';');
                            builder.Append(' ');
                        }
                    else
                        builder.Append("get; ");  // body-expression syntax: "=> "
                    builder.Append('}');

                    builder.Append('\n');
                    builder.Append('\n');

                    break;
                }

                case IndexerDeclarationSyntax indexerDeclarationSyntax: {
                    if (indexerDeclarationSyntax.GetAttribute("IgnoreAutoInterface") != null)
                        break;

                    // public or explicit interface specifier
                    if (!indexerDeclarationSyntax.Modifiers.Contains("public"))
                        if (!(indexerDeclarationSyntax.ExplicitInterfaceSpecifier?.Name is IdentifierNameSyntax identifierSyntax && identifierSyntax.Identifier.ValueText == attribute.name))
                            break;

                    string? modifiers;
                    if (!indexerDeclarationSyntax.Modifiers.Contains("static"))
                        modifiers = string.Empty; // object-method (non static)
                    else if (attribute.staticMembers)
                        modifiers = "static abstract "; // static-method and static is enabled
                    else
                        break;  // ignore static member


                    // summary
                    {
                        SyntaxTriviaList triviaList = indexerDeclarationSyntax.AttributeLists.Count switch {
                            > 0 => indexerDeclarationSyntax.AttributeLists[0].GetLeadingTrivia(),
                            _ => indexerDeclarationSyntax.Modifiers.Count switch {
                                > 0 => indexerDeclarationSyntax.Modifiers[0].LeadingTrivia,
                                _ => indexerDeclarationSyntax.Type.GetLeadingTrivia()
                            }
                        };
                        foreach (SyntaxTrivia trivia in triviaList)
                            if (trivia.GetStructure() is DocumentationCommentTriviaSyntax documentationCommentTrivia) {
                                builder.Append("    ///");
                                builder.Append(documentationCommentTrivia.ToString());
                                break;
                            }
                    }

                    builder.Append("    ");
                    builder.Append(modifiers);
                    builder.Append(indexerDeclarationSyntax.Type.ToString());
                    builder.Append(' ');
                    builder.Append("this");
                    builder.Append(indexerDeclarationSyntax.ParameterList.ToString());
                    builder.Append(' ');

                    builder.Append('{');
                    builder.Append(' ');
                    if (indexerDeclarationSyntax.AccessorList != null)
                        foreach (AccessorDeclarationSyntax accessor in indexerDeclarationSyntax.AccessorList.Accessors) {
                            if (accessor.Modifiers.Count > 0) // non public
                                continue;

                            builder.Append(accessor.Keyword.ValueText);
                            builder.Append(';');
                            builder.Append(' ');
                        }
                    else
                        builder.Append("get; ");  // body-expression syntax: "=> "
                    builder.Append('}');

                    builder.Append('\n');
                    builder.Append('\n');

                    break;
                }

                case EventFieldDeclarationSyntax eventFieldDeclarationSyntax: {
                    if (eventFieldDeclarationSyntax.GetAttribute("IgnoreAutoInterface") != null)
                        break;

                    if (!eventFieldDeclarationSyntax.Modifiers.Contains("public"))
                        break;

                    string? modifiers;
                    if (!eventFieldDeclarationSyntax.Modifiers.Contains("static"))
                        modifiers = string.Empty; // object-method (non static)
                    else if (attribute.staticMembers)
                        modifiers = "static abstract "; // static-method and static is enabled
                    else
                        break;  // ignore static member


                    // summary
                    {
                        SyntaxTriviaList triviaList = eventFieldDeclarationSyntax.AttributeLists.Count switch {
                            > 0 => eventFieldDeclarationSyntax.AttributeLists[0].GetLeadingTrivia(),
                            _ => eventFieldDeclarationSyntax.Modifiers.Count switch {
                                > 0 => eventFieldDeclarationSyntax.Modifiers[0].LeadingTrivia,
                                _ => eventFieldDeclarationSyntax.EventKeyword.LeadingTrivia
                            }
                        };
                        foreach (SyntaxTrivia trivia in triviaList)
                            if (trivia.GetStructure() is DocumentationCommentTriviaSyntax documentationCommentTrivia) {
                                builder.Append("    ///");
                                builder.Append(documentationCommentTrivia.ToString());
                                break;
                            }
                    }

                    builder.Append("    ");
                    builder.Append(modifiers);
                    builder.Append("event ");
                    builder.Append(eventFieldDeclarationSyntax.Declaration.Type.ToString());
                    builder.Append(' ');
                    builder.Append(eventFieldDeclarationSyntax.Declaration.Variables.ToString());
                    builder.Append(';');

                    builder.Append('\n');
                    builder.Append('\n');

                    break;
                }

                case EventDeclarationSyntax eventDeclarationSyntax: {
                    if (eventDeclarationSyntax.GetAttribute("IgnoreAutoInterface") != null)
                        break;

                    // public or explicit interface specifier
                    if (!eventDeclarationSyntax.Modifiers.Contains("public"))
                        if (!(eventDeclarationSyntax.ExplicitInterfaceSpecifier?.Name is IdentifierNameSyntax identifierSyntax && identifierSyntax.Identifier.ValueText == attribute.name))
                            break;

                    string? modifiers;
                    if (!eventDeclarationSyntax.Modifiers.Contains("static"))
                        modifiers = string.Empty; // object-method (non static)
                    else if (attribute.staticMembers)
                        modifiers = "static abstract "; // static-method and static is enabled
                    else
                        break;  // ignore static member


                    // summary
                    {
                        SyntaxTriviaList triviaList = eventDeclarationSyntax.AttributeLists.Count switch {
                            > 0 => eventDeclarationSyntax.AttributeLists[0].GetLeadingTrivia(),
                            _ => eventDeclarationSyntax.Modifiers.Count switch {
                                > 0 => eventDeclarationSyntax.Modifiers[0].LeadingTrivia,
                                _ => eventDeclarationSyntax.EventKeyword.LeadingTrivia
                            }
                        };
                        foreach (SyntaxTrivia trivia in triviaList)
                            if (trivia.GetStructure() is DocumentationCommentTriviaSyntax documentationCommentTrivia) {
                                builder.Append("    ///");
                                builder.Append(documentationCommentTrivia.ToString());
                                break;
                            }
                    }

                    builder.Append("    ");
                    builder.Append(modifiers);
                    builder.Append("event ");
                    builder.Append(eventDeclarationSyntax.Type.ToString());
                    builder.Append(' ');
                    builder.Append(eventDeclarationSyntax.Identifier.ToString());
                    builder.Append(';');

                    builder.Append('\n');
                    builder.Append('\n');

                    break;
                }
            }
        }

        builder.Length--;
        builder.Append('}');
        builder.Append('\n');


        string interfaceName = attribute.name;
        string sourceCode = builder.ToString();
        string hash = Convert.ToBase64String(BitConverter.GetBytes(sourceCode.GetHashCode()))
            .TrimEnd('=')
            .Replace('+', '-')
            .Replace('/', '_');

        context.AddSource($"{interfaceName}.{hash}.g.cs", sourceCode);
    }
}
