# AutoInterface

AutoInterface is a source generator that generates an interface based on your class/struct.  
Basically, you write your class and get the corresponding interface for free.

```csharp
using AutoInterfaceAttributes;

[AutoInterface]
public class Example : IExample {
    public int Number { get; private set; }

    public Example() {
        ResetNumber();
    }

    /// <summary>
    /// some method description
    /// </summary>
    public int AddToNumber(int increase) {
        Number += increase;
        return Number;
    }

    private void ResetNumber() => Number = 0;
}
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IExample {
    int Number { get; }

    /// <summary>
    /// some method description
    /// </summary>
    int AddToNumber(int increase);
}
```

AutoInterface supports:

- [classes and structs](#autointerfaceattribute-on-struct)
- [all members (Method, Property, Indexer, Event)](#autointerfaceattribute-with-all-kinds-of-members)
- [also explicit Interface members](#autointerfaceattribute-with-explicit-interface-specifier)
- [multiple attributes on same class](#multiple-autointerfaceattributes-on-same-class)
- [summary of class/struct and members](#autointerfaceattribute-with-summary-documentation)
- [generic](#autointerfaceattribute-with-generic-class)
- parameters for
  * [interface name](#name)
  * [interface modifier](#modifier)
  * [interface namespace](#namespace)
  * [interface inheritance](#inheritance)
  * [static members as static abstract](#staticmembers)
  * [ignore specific members](#ignoreautointerfaceattribute)



<br></br>
## Exmples

### AutoInterfaceAttribute on struct

```csharp
using AutoInterfaceAttributes;

[AutoInterface]
public struct Point {
    public int X { get; private set; }
    public int Y { get; private set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IPoint {
    int X { get; }

    int Y { get; }
}
```


<br></br>
### AutoInterfaceAttribute with all kinds of members

```csharp
using AutoInterfaceAttributes;

[AutoInterface]
public sealed class FullExample {
    public void SomeMethod() { }

    public int SomeProperty { get; init; }

    public int this[int i] => i;

    public event Action? someEvent;

    public event Action SomeEvent { add { } remove { } }
}
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IFullExample {
    void SomeMethod();

    int SomeProperty { get; init; }

    int this[int i] { get; }

    event Action? someEvent;

    event Action SomeEvent;
}
```


<br></br>
### AutoInterfaceAttribute with explicit interface specifier

```csharp
using AutoInterfaceAttributes;

[AutoInterface]
public sealed class ExplicitExample : IExplicitExample {
    void IExplicitExample.SomeMethod() { }

    int IExplicitExample.SomeProperty { get; init; }

    int IExplicitExample.this[int i] => i;

    event Action IExplicitExample.SomeEvent { add { } remove { } }
}
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IExplicitExample {
    void SomeMethod();

    int SomeProperty { get; init; }

    int this[int i] { get; }

    event Action SomeEvent;
}
```


<br></br>
### multiple AutoInterfaceAttributes on same class

```csharp
using AutoInterfaceAttributes;

[AutoInterface(Name = "IMultipleExample1")]
[AutoInterface(Name = "IMultipleExample2")]
public sealed class MultipleExample : IMultipleExample1, IMultipleExample2 {
    public void SomeMethod() { }

    int IMultipleExample1.PropertyFirst { get; set; }

    string IMultipleExample2.PropertySecond { get; set; }
}
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IMultipleExample1 {
    void SomeMethod();

    int PropertyFirst { get; set; }
}

...

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IMultipleExample2 {
    void SomeMethod();

    string PropertySecond { get; set; }
}
```


<br></br>
### AutoInterfaceAttribute with summary documentation

```csharp
using AutoInterfaceAttributes;

/// <summary>
/// my class description
/// </summary>
[AutoInterface]
public sealed class SummaryExample {
    /// <summary>
    /// some method description
    /// </summary>
    public void SomeMethod() { }
}
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

/// <summary>
/// my class description
/// </summary>
public interface ISummaryExample {
    /// <summary>
    /// some method description
    /// </summary>
    void SomeMethod();
}
```


<br></br>
### AutoInterfaceAttribute with generic class

```csharp
using AutoInterfaceAttributes;

[AutoInterface]
public sealed class GenericExample<T> {
    public T Identity(T parameter) => parameter;
}
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IGenericExample<T> {
    T Identity(T parameter);
}
```


<br><br />
## Parameter

- ### Name

Type: string  
Default: $"I\{ClassName\}"

If you want another name for your interface, put it here.

```csharp
using AutoInterfaceAttributes;

[AutoInterface(Name = "NewName")]
public sealed class Example { }
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface NewName {}
```


<br></br>
- ### Modifier

Type: string  
Default: "public"

If you want another visible modifier or make the interface partial or unsafe, you can do this here.

```csharp
using AutoInterfaceAttributes;

[AutoInterface(Modifier = "internal partial")]
public sealed class Example { }
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

internal partial interface IExample {}
```


<br></br>
- ### Namespace

Type: string  
Default: $"\{ClassNamespace\}"

When the generated interface should live in a specific namespace, you can specify it here.  
For global namespace, use an empty string.

```csharp
using AutoInterfaceAttributes;

namespace MyApp.Core;

[AutoInterface(Namespace = "MyApp.Utils")]
public sealed class Example { }
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

namespace MyApp.Utils;

public interface IExample {}
```


<br></br>
- ### Inheritance

Type: Type[]  
Default: Array.Empty\<Type\>()

If the generated interface should inherit from one or more other interfaces, you can list them here.

```csharp
using AutoInterfaceAttributes;

[AutoInterface(Inheritance = [typeof(ICore)])]
public sealed class Example { }

public interface ICore { ... }
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IExample : ICore {}
```


<br></br>
- ### StaticMembers

Type: bool  
Default: false

Normally, static members are just ignored.
However, an interface can contain static members as a "static abstract" member.  
To accept static members to generate "static abstract" members, set this flag to true.

```csharp
using AutoInterfaceAttributes;

[AutoInterface(StaticMembers = true)]
public sealed class Example {
    public static void SomeMethod() { }
}
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IExample {
    static abstract void SomeMethod();
}
```


<br></br>
- ### IgnoreAutoInterfaceAttribute

When you want a specific member to be ignored by the generator, you can decorate it with [IgnoreAutoInterface].

```csharp
using AutoInterfaceAttributes;

[AutoInterface]
public sealed class Example {
    [IgnoreAutoInterface]
    public void SomeMethod() { }
}
```

```csharp
// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IExample {}
```



<br></br>
## Disable Attribute Generation

You can disable the generation of the attributes by defining a constant for your compilation:

```xml
  <PropertyGroup>
    <DefineConstants>AUTOINTERFACE_EXCLUDE_ATTRIBUTES</DefineConstants>
  </PropertyGroup>
```

This functionality is specific for the use case when you have a project referencing another project, both projects using this generator and you have <i>InternalsVisibleTo</i> enabled.
In that case you have the attributes defined twice in your referencing project and you get a warning about that.
By defining this constant in your referencing project, you prevent one generation, so the attributes are only defined once in the referenced project.



<br></br>
## Remarks

Using-statements will always be placed on the top, so using not fully-qualified using-statements might cause compile errors.

```csharp
using AutoInterfaceAttributes;

namespace System.Collections {
    using Generic; // <-- refers to "System.Collections.Generic"

    [AutoInterface]
    public sealed class Example { }
}


// ...


// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using Generic; // <-- refers to "Generic"
using AutoInterfaceAttributes;

public interface IExample {}
```

You also should not use not fully-qualified using-statements in the first place, because they can be ambiguous.
By introducing an additional namespace, the referring of a not fully-qualified using-statement might change and your application breaks at unrelated places.
Just put your using statements at the top.
