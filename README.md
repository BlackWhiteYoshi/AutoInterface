# AutoInterface

AutoInterface is a source generator that generates an interface based on your class/struct.  
Basically, you write your class and get the corresponding interface for free.

```csharp
using AutoInterfaceAttributes;

[AutoInterface]
public class Example : IExample {
    public int Number { get; private set; }

    public Example() {
        ResetNumber();
    }

    /// <summary>
    /// some method description
    /// </summary>
    public int AddToNumber(int increase) {
        Number += increase;
        return Number;
    }

    private void ResetNumber() => Number = 0;
}
```

```csharp
// <auto-generated>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IExample {
    int Number { get; }

    /// <summary>
    /// some method description
    /// </summary>
    int AddToNumber(int increase);
}
```

AutoInterface supports:

- [classes and structs](#autointerfaceattribute-on-struct)
- [all members (Method, Property, Indexer, Event)](#autointerfaceattribute-with-all-kinds-of-members)
- [also explicit Interface members](#autointerfaceattribute-with-explicit-interface-specifier)
- [summary of class/struct and members](#autointerfaceattribute-with-summary-documentation)
- [generic](#autointerfaceattribute-with-generic-class)
- parameters for
  * [interface name](#name)
  * [interface modifier](#modifier)
  * [interface namespace](#namespace)
  * [interface inheritance](#inheritance)
  * [static members as static abstract](#staticmembers)
  * [ignore specific members](#ignoreautointerfaceattribute)

<br></br>
## Exmples

### AutoInterfaceAttribute on struct

```csharp
using AutoInterfaceAttributes;

[AutoInterface]
public struct Point {
    public int X { get; private set; }
    public int Y { get; private set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

```csharp
// <auto-generated>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IPoint {
    int X { get; }

    int Y { get; }
}
```


<br></br>
### AutoInterfaceAttribute with all kinds of members

```csharp
using AutoInterfaceAttributes;

[AutoInterface]
public sealed class FullExample {
    public void SomeMethod() { }

    public int SomeProperty { get; init; }

    public int this[int i] => i;

    public event Action? someEvent;

    public event Action SomeEvent { add { } remove { } }
}
```

```csharp
// <auto-generated>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IFullExample {
    void SomeMethod();

    int SomeProperty { get; init; }

    int this[int i] { get; }

    event Action? someEvent;

    event Action SomeEvent;
}
```


<br></br>
### AutoInterfaceAttribute with explicit interface specifier

```csharp
using AutoInterfaceAttributes;

[AutoInterface]
public sealed class ExplicitExample : IExplicitExample {
    void IExplicitExample.SomeMethod() { }

    int IExplicitExample.SomeProperty { get; init; }

    int IExplicitExample.this[int i] => i;

    event Action IExplicitExample.SomeEvent { add { } remove { } }
}
```

```csharp
// <auto-generated>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IExplicitExample {
    void SomeMethod();

    int SomeProperty { get; init; }

    int this[int i] { get; }

    event Action SomeEvent;
}
```


<br></br>
### AutoInterfaceAttribute with summary documentation

```csharp
using AutoInterfaceAttributes;

/// <summary>
/// my class description
/// </summary>
[AutoInterface]
public sealed class SummaryExample {
    /// <summary>
    /// some method description
    /// </summary>
    public void SomeMethod() { }
}
```

```csharp
// <auto-generated>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

/// <summary>
/// my class description
/// </summary>
public interface ISummaryExample {
    /// <summary>
    /// some method description
    /// </summary>
    void SomeMethod();
}
```


<br></br>
### AutoInterfaceAttribute with generic class

```csharp
using AutoInterfaceAttributes;

[AutoInterface]
public sealed class GenericExample<T> {
    public T Identity(T parameter) => parameter;
}
```

```csharp
// <auto-generated>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IGenericExample<T> {
    T Identity(T parameter);
}
```


<br><br />
## Parameter

- ### Name

Type: string  
Default: $"I\{ClassName\}"

If you want another name for your interface, put it here.

```csharp
using AutoInterfaceAttributes;

[AutoInterface(Name = "NewName")]
public sealed class Example { }
```

```csharp
// <auto-generated>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface NewName {}
```


<br></br>
- ### Modifier

Type: string  
Default: "public"

If you want another visible modifier or make the interface partial or unsafe, you can do this here.

```csharp
using AutoInterfaceAttributes;

[AutoInterface(Modifier = "internal partial")]
public sealed class Example { }
```

```csharp
// <auto-generated>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

internal partial interface IExample {}
```


<br></br>
- ### Namespace

Type: string  
Default: $"\{ClassNamespace\}"

When the generated interface should live in a specific namespace, you can specify it here.  
For global namespace, use an empty string.

```csharp
using AutoInterfaceAttributes;

namespace MyApp.Core;

[AutoInterface(Namespace = "MyApp.Utils")]
public sealed class Example { }
```

```csharp
// <auto-generated>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

namespace MyApp.Utils;

public interface IExample {}
```


<br></br>
- ### Inheritance

Type: Type[]  
Default: Array.Empty\<Type\>()

If the generated interface should inherit from one or more other interfaces, you can list them here.

```csharp
using AutoInterfaceAttributes;

[AutoInterface(Inheritance = new[] { typeof(ICore) })]
public sealed class Example { }

public interface ICore { ... }
```

```csharp
// <auto-generated>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IExample : ICore {}
```


<br></br>
- ### StaticMembers

Type: bool  
Default: false

Normally, static members are just ignored.
However, an interface can contain static members as a "static abstract" member.  
To accept static members to generate "static abstract" members, set this flag to true.

```csharp
using AutoInterfaceAttributes;

[AutoInterface(StaticMembers = true)]
public sealed class Example {
    public static void SomeMethod() { }
}
```

```csharp
// <auto-generated>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IExample {
    static abstract void SomeMethod();
}
```


<br></br>
- ### IgnoreAutoInterfaceAttribute

When you want a specific member to be ignored by the generator, you can decorate it with [IgnoreAutoInterface].

```csharp
using AutoInterfaceAttributes;

[AutoInterface]
public sealed class Example {
    [IgnoreAutoInterface]
    public void SomeMethod() { }
}
```

```csharp
// <auto-generated>
#pragma warning disable
#nullable enable annotations


using AutoInterfaceAttributes;

public interface IExample {}
```
